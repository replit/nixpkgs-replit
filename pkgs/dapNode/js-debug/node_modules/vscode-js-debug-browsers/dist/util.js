"use strict";
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.findWindowsCandidates = exports.sort = exports.preferredEdgePath = exports.preferredChromePath = exports.escapeRegexSpecialChars = exports.canAccess = void 0;
const path_1 = require("path");
/**
 * Returns whether the user can access the given file path.
 */
async function canAccess({ access }, file) {
    if (!file) {
        return false;
    }
    try {
        await access(file);
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.canAccess = canAccess;
const regexChars = '/\\.?*()^${}|[]+';
/**
 * Escape regex special characters from the string.
 */
function escapeRegexSpecialChars(str, except) {
    const useRegexChars = regexChars
        .split('')
        .filter(c => !except || except.indexOf(c) < 0)
        .join('')
        .replace(/[\\\]]/g, '\\$&');
    const r = new RegExp(`[${useRegexChars}]`, 'g');
    return str.replace(r, '\\$&');
}
exports.escapeRegexSpecialChars = escapeRegexSpecialChars;
/**
 * Gets the configured Chrome path, if any.
 */
async function preferredChromePath(fs, env) {
    if (await canAccess(fs, env.CHROME_PATH)) {
        return env.CHROME_PATH;
    }
}
exports.preferredChromePath = preferredChromePath;
/**
 * Gets the configured Edge path, if any.
 */
async function preferredEdgePath(fs, env) {
    if (await canAccess(fs, env.EDGE_PATH)) {
        return env.EDGE_PATH;
    }
}
exports.preferredEdgePath = preferredEdgePath;
/**
 * Sorts the set of installations,
 */
function sort(installations, priorities) {
    const defaultPriority = 10;
    return ([...installations]
        .filter(inst => !!inst)
        .map(inst => {
        const priority = priorities.find(p => p.regex.test(inst));
        return priority
            ? { path: inst, weight: priority.weight, quality: priority.quality }
            : { path: inst, weight: defaultPriority, quality: "dev" /* Dev */ };
    })
        // sort based on weight
        .sort((a, b) => b.weight - a.weight)
        // remove weight
        .map(p => ({ path: p.path, quality: p.quality })));
}
exports.sort = sort;
/**
 * Finds binaries for Windows platforms by looking for the given path
 * suffixes in each of the local app data and program files directories
 * on the machine, returning complete absolute paths that match.
 */
async function findWindowsCandidates(env, fs, suffixes) {
    const prefixes = [env.LOCALAPPDATA, env.PROGRAMFILES, env['PROGRAMFILES(X86)']].filter((p) => !!p);
    const todo = [];
    for (const prefix of prefixes) {
        for (const suffix of suffixes) {
            const candidate = path_1.win32.join(prefix, suffix.name);
            todo.push(canAccess(fs, candidate).then(ok => ok ? { path: candidate, quality: suffix.type } : undefined));
        }
    }
    return (await Promise.all(todo)).filter((e) => !!e);
}
exports.findWindowsCandidates = findWindowsCandidates;
//# sourceMappingURL=util.js.map