import{Fragment as e,options as t,Component as n}from"preact";import{MODE_UNMOUNTING as o}from"preact/src/constants";import"preact/devtools";let r={};function i(){r={}}function a(t){return t.type===e?"Fragment":"function"==typeof t.type?t.type.displayName||t.type.name:"string"==typeof t.type?t.type:"#text"}let s=[],c=[];function l(){return s.length>0?s[s.length-1]:null}let p=!1;function u(t){return"function"==typeof t.type&&t.type!=e}function d(e){const t=[e];let n=e;for(;null!=n.__o;)t.push(n.__o),n=n.__o;return t.reduce((e,t)=>{e+=`  in ${a(t)}`;const n=t.props&&t.props.__source;return n?e+=` (at ${n.fileName}:${n.lineNumber})`:p||(p=!0,console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")),e+"\n"},"")}const f="function"==typeof WeakMap;function h(e){return e?"function"==typeof e.type?h(e.__):e:{}}const y=n.prototype.setState;n.prototype.setState=function(e,t){return null==this.__i?null==this.state&&console.warn(`Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n${d(l())}`):this.__i.__f&o&&console.warn(`Can't call "this.setState" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n${d(this.__i)}`),y.call(this,e,t)};const m=n.prototype.forceUpdate;function b(e){let{props:t}=e,n=a(e),o="";for(let e in t)if(t.hasOwnProperty(e)&&"children"!==e){let n=t[e];"function"==typeof n&&(n=`function ${n.displayName||n.name}() {}`),n=Object(n)!==n||n.toString?n+"":Object.prototype.toString.call(n),o+=` ${e}=${JSON.stringify(n)}`}let r=t.children;return`<${n}${o}${r&&r.length?">..</"+n+">":" />"}`}n.prototype.forceUpdate=function(e){return null==this.__i?console.warn(`Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n${d(l())}`):this.__i.__f&o&&console.warn(`Can't call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n${d(this.__i)}`),m.call(this,e)},function(){!function(){let e=t.__b,n=t.diffed,o=t.__,r=t.vnode,i=t.__i,a=t.__r;t.diffed=e=>{u(e)&&c.pop(),s.pop(),n&&n(e)},t.__b=(t,n)=>{u(t)&&s.push(t),e&&e(t,n)},t.__=(e,t)=>{c=[],o&&o(e,t)},t.vnode=e=>{e.__o=c.length>0?c[c.length-1]:null,r&&r(e)},t.__i=(e,t)=>{null!==e.type&&(e.__o=t.__o),i&&i(e,t)},t.__r=e=>{u(e)&&c.push(e),a&&a(e)}}();let e=!1,n=t.__b,o=t.diffed,i=t.vnode,l=t.__e,p=t.__,y=t.__h;const m=f?{useEffect:new WeakMap,useLayoutEffect:new WeakMap,lazyPropTypes:new WeakMap}:null,$=[];t.__e=(e,t,n)=>{if(t&&t.__c&&"function"==typeof e.then){const n=e;e=new Error(`Missing Suspense. The throwing component was: ${a(t)}`);let o=t;for(;o;o=o.__)if(o.__c&&o.__c.__c){e=n;break}if(e instanceof Error)throw e}try{l(e,t,n),"function"!=typeof e.then&&setTimeout(()=>{throw e})}catch(e){throw e}},t.__=(e,t)=>{if(!t)throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");let n;switch(t.nodeType){case 1:case 11:case 9:n=!0;break;default:n=!1}if(!n){let n=a(e);throw new Error(`Expected a valid HTML node as a second argument to render.\tReceived ${t} instead: render(<${n} />, ${t});`)}p&&p(e,t)},t.__b=(t,o)=>{if(null===o||"object"!=typeof o)return;if(void 0!==o.constructor){const e=Object.keys(o).join(",");throw new Error(`Objects are not valid as a child. Encountered an object with the keys {${e}}.\n\n${d(t)}`)}let{type:i,__:s}=t;if(void 0===i)throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports"+b(o)+`\n\n${d(t)}`);if(null!=i&&"object"==typeof i){if(void 0===i.constructor)throw new Error(`Invalid type passed to createElement(): ${i}\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My${a(t)} = ${b(i)};\n  let vnode = <My${a(t)} />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n${d(t)}`);throw new Error("Invalid type passed to createElement(): "+(Array.isArray(i)?"array":i))}let c=h(s);if(e=!0,"thead"!==i&&"tfoot"!==i&&"tbody"!==i||"table"===c.type?"tr"===i&&"thead"!==c.type&&"tfoot"!==c.type&&"tbody"!==c.type&&"table"!==c.type?console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent."+b(t)+`\n\n${d(t)}`):"td"===i&&"tr"!==c.type?console.error("Improper nesting of table. Your <td> should have a <tr> parent."+b(t)+`\n\n${d(t)}`):"th"===i&&"tr"!==c.type&&console.error("Improper nesting of table. Your <th> should have a <tr>."+b(t)+`\n\n${d(t)}`):console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent."+b(t)+`\n\n${d(t)}`),void 0!==t.ref&&"function"!=typeof t.ref&&"object"!=typeof t.ref&&!("$$typeof"in o))throw new Error(`Component's "ref" property should be a function, or an object created by createRef(), but got [${typeof t.ref}] instead\n`+b(t)+`\n\n${d(t)}`);if("string"==typeof t.type)for(const e in o.props)if("o"===e[0]&&"n"===e[1]&&"function"!=typeof o.props[e]&&null!=o.props[e])throw new Error(`Component's "${e}" property should be a function, but got [${typeof o.props[e]}] instead\n`+b(o)+`\n\n${d(t)}`);if("function"==typeof t.type&&t.type.propTypes){if("Lazy"===t.type.displayName&&m&&!m.lazyPropTypes.has(t.type)){const e="PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";try{const n=t.type();m.lazyPropTypes.set(t.type,!0),console.warn(e+`Component wrapped in lazy() is ${a(n)}`)}catch(t){console.warn(e+"We will log the wrapped component's name once it is loaded.")}}let e=o?o.props:t.props;t.type.__f&&(e=Object.assign({},e),delete e.ref),function(e,t,n,o,i){Object.keys(e).forEach(n=>{let a;try{a=e[n](t,n,o,"prop",null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(e){a=e}a&&!(a.message in r)&&(r[a.message]=!0,console.error(`Failed prop type: ${a.message}${i&&`\n${i()}`||""}`))})}(t.type.propTypes,e,0,a(t),()=>d(t))}n&&n(t,o)},t.__h=(t,n,o)=>{if(!t||!e)throw new Error("Hook can only be invoked from render methods.");y&&y(t,n,o)};const w=(e,t)=>({get(){const n="get"+e+t;$&&$.indexOf(n)<0&&($.push(n),console.warn(`getting vnode.${e} is deprecated, ${t}`))},set(){const n="set"+e+t;$&&$.indexOf(n)<0&&($.push(n),console.warn(`setting vnode.${e} is not allowed, ${t}`))}}),g={nodeName:w("nodeName","use vnode.type"),attributes:w("attributes","use vnode.props"),children:w("children","use vnode.props.children")},v={__source:{enumerable:!1},__self:{enumerable:!1}},E=Object.create({},g);t.vnode=e=>{const t=e.props;null!=t&&("__source"in t||"__self"in t)&&(Object.defineProperties(t,v),e.__source=t.__source,e.__self=t.__self),e.__proto__=E,i&&i(e)},t.diffed=t=>{if(e=!1,o&&o(t),null!=t.__k){const e=[];for(let n=0;n<t.__k.length;n++){const o=t.__k[n];if(!o||null==o.key)continue;const r=o.key;if(-1!==e.indexOf(r)){console.error(`Following component has two or more children with the same key attribute: "${r}". This may cause glitches and misbehavior in rendering process. Component: \n\n`+b(t)+`\n\n${d(t)}`);break}e.push(r)}}}}();export{i as resetPropWarnings};
//# sourceMappingURL=debug.modern.js.map
